---
title: Enterprise MCP Management
description: How the Gateway transforms MCP servers into enterprise governance tools with toggleable controls
sidebar: Enterprise Management
icon: Building2
---

import { Card, Cards } from 'fumadocs-ui/components/card';
import { Building2, ToggleLeft, Eye, Shield } from 'lucide-react';

# Enterprise MCP Management

The DeployStack Gateway transforms individual MCP servers into enterprise governance tools, presenting each server as a toggleable tool with comprehensive management capabilities for organizational control.

## Business Context

### The Enterprise Challenge
Traditional MCP implementations expose individual tools from multiple servers, creating a complex landscape that's difficult to govern at scale. Enterprise organizations need:

- **Visibility**: Clear overview of which MCP servers are available and active
- **Control**: Ability to enable/disable entire MCP servers based on policy
- **Governance**: Centralized management with audit trails
- **Compliance**: Team-based access controls and usage monitoring

### DeployStack Solution
The Gateway addresses these challenges by presenting **MCP servers as tools** rather than exposing individual server tools, enabling enterprise governance while maintaining developer productivity.

## Architecture Overview

<Cards>
  <Card 
    icon={<Building2 />} 
    title="Server-as-Tool Model"
  >
    Each MCP server appears as a single toggleable tool with rich metadata
  </Card>
  
  <Card 
    icon={<ToggleLeft />} 
    title="Management Actions"
  >
    Enable, disable, and status operations for operational control
  </Card>
  
  <Card 
    icon={<Eye />} 
    title="Enterprise Visibility"
  >
    Rich descriptions and metadata from secure catalog integration
  </Card>
  
  <Card 
    icon={<Shield />} 
    title="Policy Enforcement"
  >
    Team-based access controls with centralized governance
  </Card>
</Cards>

## Tool Transformation

### From Individual Tools to Server Management
**Traditional MCP Approach:**
```json
{
  "tools": [
    {"name": "brightdata__search", "description": "Search the web"},
    {"name": "brightdata__scrape", "description": "Scrape webpage content"},
    {"name": "calculator__add", "description": "Add two numbers"},
    {"name": "calculator__multiply", "description": "Multiply numbers"}
  ]
}
```

**DeployStack Enterprise Approach:**
```json
{
  "tools": [
    {
      "name": "brightdata-mcp",
      "description": "brightdata-mcp MCP server - Web scraping and data collection",
      "inputSchema": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "enum": ["enable", "disable", "status"]
          }
        }
      }
    },
    {
      "name": "calculator-server",
      "description": "calculator-server MCP server - Mathematical operations and calculations",
      "inputSchema": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "enum": ["enable", "disable", "status"]
          }
        }
      }
    }
  ]
}
```

## Management Actions

### Enable Action
**Purpose**: Activate an MCP server for use
**Usage**: `{"action": "enable"}`

**Process:**
1. Validates server configuration from team catalog
2. Spawns MCP server process with injected credentials
3. Establishes stdio communication channel
4. Returns operational status and process information

**Response Example:**
```json
{
  "server": "brightdata-mcp",
  "action": "enabled",
  "status": "running",
  "message": "brightdata-mcp MCP server has been enabled and is running"
}
```

### Disable Action
**Purpose**: Deactivate a running MCP server
**Usage**: `{"action": "disable"}`

**Process:**
1. Locates running MCP server process
2. Gracefully terminates process with 5-second timeout
3. Cleans up resources and communication channels
4. Confirms successful shutdown

**Response Example:**
```json
{
  "server": "brightdata-mcp",
  "action": "disabled",
  "status": "stopped",
  "message": "brightdata-mcp MCP server has been disabled"
}
```

### Status Action (Default)
**Purpose**: Retrieve comprehensive server information
**Usage**: `{"action": "status"}` or no action parameter

**Information Provided:**
- Current operational status (running/stopped)
- Server description from enterprise catalog
- Runtime environment details
- Performance metrics (uptime, message count, error count)
- Process health information

**Response Example:**
```json
{
  "server": "brightdata-mcp",
  "action": "status_check",
  "status": "running",
  "description": "Web scraping and data collection platform",
  "runtime": "nodejs",
  "message": "brightdata-mcp MCP server is running",
  "uptime": 1847293,
  "messageCount": 42,
  "errorCount": 0
}
```

## Enterprise Benefits

### Centralized Governance
- **Policy Enforcement**: Administrators control which MCP servers are available per team
- **Access Control**: Team-based permissions determine server availability
- **Audit Trail**: All enable/disable actions logged for compliance
- **Resource Management**: Centralized control over computational resources

### Developer Experience
- **Simplified Interface**: Developers see clean server names instead of complex tool hierarchies
- **Rich Metadata**: Comprehensive descriptions help developers understand capabilities
- **Operational Control**: Developers can manage server lifecycle as needed
- **Status Transparency**: Clear visibility into server health and performance

### Operational Excellence
- **Resource Optimization**: Servers only run when needed, reducing resource consumption
- **Error Isolation**: Server-level management isolates issues to specific services
- **Performance Monitoring**: Built-in metrics for operational visibility
- **Graceful Degradation**: Individual server failures don't impact other services

## Metadata Integration

### Catalog-Driven Descriptions
Server descriptions are pulled from the enterprise catalog stored securely:

```typescript
// From team configuration
const installation = teamConfig.installations.find(
  inst => inst.installation_name === serverName
);

const description = installation?.server?.description || '';

// Resulting tool description
const toolDescription = `${serverName} MCP server${description ? ` - ${description}` : ''}`;
```

### Rich Server Information
Each server tool includes:
- **Installation Name**: Clean, human-readable identifier
- **Description**: Business context from enterprise catalog
- **Runtime**: Technical environment (nodejs, python, go, etc.)
- **Team Context**: Access permissions and policies
- **Operational Metrics**: Performance and health data

## Security and Compliance

### Credential Management
- **Secure Injection**: Credentials injected at process spawn time
- **No Exposure**: Developers never see or handle credentials directly
- **Centralized Control**: All credentials managed through enterprise catalog
- **Audit Trail**: Credential usage tracked for compliance

### Access Control
- **Team-Based**: Server availability determined by team membership
- **Policy-Driven**: Enterprise policies control server access
- **Role-Based**: Different permissions for different team roles
- **Centralized Management**: All access control managed through cloud control plane

### Monitoring and Compliance
- **Usage Tracking**: All server interactions logged and monitored
- **Performance Metrics**: Operational data for capacity planning
- **Error Reporting**: Centralized error tracking and alerting
- **Compliance Reporting**: Audit trails for regulatory requirements

## Implementation Workflow

### Tool Discovery Flow
1. **Client Request**: Development tool calls `tools/list`
2. **Server Enumeration**: Gateway iterates through team's MCP server configurations
3. **Metadata Enrichment**: Descriptions pulled from secure catalog
4. **Tool Generation**: Each server becomes a management tool
5. **Response**: Clean list of server management tools returned

### Tool Execution Flow
1. **Action Request**: Client calls server tool with management action
2. **Server Identification**: Gateway maps tool name to server configuration
3. **Action Processing**: Enable/disable/status action executed
4. **Process Management**: Server processes spawned/terminated as needed
5. **Response**: Operational status and metadata returned

## Developer Workflow

### Typical Usage Pattern
1. **Discovery**: Developer calls `tools/list` to see available MCP servers
2. **Status Check**: Calls server tool with `status` action to understand current state
3. **Activation**: Uses `enable` action to start needed MCP servers
4. **Work**: Utilizes MCP server capabilities through other tools/interfaces
5. **Cleanup**: Uses `disable` action to stop servers when done

### VS Code Integration
In VS Code, developers see:
```
ðŸ”§ Available Tools:
â”œâ”€â”€ brightdata-mcp - brightdata-mcp MCP server - Web scraping and data collection
â”œâ”€â”€ calculator-server - calculator-server MCP server - Mathematical operations
â””â”€â”€ github-integration - github-integration MCP server - GitHub API access
```

Each tool can be toggled on/off with simple actions, providing enterprise governance with developer-friendly controls.

## Developer Tool Discovery

### CLI-Based Exploration
Before enabling MCP servers through the enterprise management interface, developers can explore available tools using the CLI tool discovery feature:

**Command**: `deploystack mcp --tools <server-number>`

**Purpose**: Allows developers to understand what capabilities each MCP server provides before activation, enabling informed decisions about which servers to enable for their workflow.

**Benefits**:
- **Preview Capabilities**: See all available tools and their descriptions without starting the server
- **Parameter Understanding**: Review required and optional parameters for each tool
- **Informed Decisions**: Choose the right MCP servers based on actual tool availability
- **Development Planning**: Plan workflows around available tool capabilities

### Integration with Enterprise Management
The CLI tool discovery complements the enterprise management approach:

1. **Discovery Phase**: Developer uses `deploystack mcp --tools` to explore server capabilities
2. **Planning Phase**: Developer identifies which servers provide needed functionality
3. **Activation Phase**: Developer enables specific servers through enterprise management tools
4. **Utilization Phase**: Developer uses the activated servers' capabilities in their workflow

This workflow ensures developers make informed decisions about server activation while maintaining enterprise governance and control.

The enterprise management layer transforms complex MCP server ecosystems into manageable, governable, and developer-friendly tools that meet both organizational requirements and developer productivity needs.
